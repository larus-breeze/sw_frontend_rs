use embedded_graphics::geometry::AngleUnit;

use crate::{
    controller::Editable,
    flight_physics::{GliderData, Wind}, 
    system_of_units::{FloatToSpeed, Speed, Pressure},
    AirSpeed, Density, 
};

/// Data model for the entire device
///
/// In the CoreModel all variables of the display are kept in a structure, which is used by
/// different modules. The CoreModel is filled by the CoreController, which holds the different
/// channels to the data sources like Larus, controls, sensors, inputs and time. The View
/// modules display the data contents. The LCD display and the sound system are the most
/// important ones.
#[derive(Default)]
pub struct CoreModel {
    pub calculated: Calculated,
    pub config: Config,
    pub control: Control,
    pub glider_data: GliderData,
    pub sensor: Sensor,
}

/// Flymode display variants
///
/// Flymode::Circling is displayed while circling upwind. In addition to vario signal and wind,
/// the average climb is also displayed.
///
/// In Flymode::StraightFlight the mean climb is hidden and the speed command is displayed
/// graphically and as a number.#[repr(u8)]
#[repr(u8)]
pub enum FlyMode {
    Circling,
    StraightFlight,
}

/// This enum is relevant for the View component. During Vario mode, information needed to 
/// optimize climbing in thermals is displayed. SppedToFly, on the other hand, is intended 
/// for optimal pre-flight. 
#[repr(u8)]
pub enum VarioMode {
    Vario,
    SpeedToFly,
}

/// Enum mode controls whether the background should be visible or not when editing a data 
/// point.
#[repr(u8)]
pub enum EditMode {
    Section,
    Fullscreen,
}

/// Possible displays
#[repr(u8)]
pub enum DisplayActive {
    Vario,
}


/// Metastructure for calculated or set values
pub struct Calculated {
    pub mc_cready: Speed,
    pub speed_to_fly: AirSpeed,
    pub speed_to_fly_dif: Speed,
    pub thermal_climb_rate: Speed,
}

impl Default for Calculated {
    #[allow(unused)]
    fn default() -> Self {
        Calculated {
            mc_cready: 0.7.m_s(),
            speed_to_fly: AirSpeed::from_tas_at_nn(127.0.km_h()),
            speed_to_fly_dif: 3.0.km_h(),
            thermal_climb_rate: 1.3.m_s(),
        }
    }
}

/// Metastructur for config variable, which are saved in EEPROM
#[repr(C, packed)]  // Config will be saved as a binary copy, so we need a fixed layout
pub struct Config {
    pub version: u16,
    pub magic: u64,
    pub display_active: DisplayActive,
    pub glider_idx: i32,
    pub volume: i8,
}

const VERSION: u16 = 1;
const MAGIC: u64 = 0x_4204_17bd_4596_4242; 

impl Default for Config {
    fn default() -> Self {
        Self {
            version: VERSION,
            magic: MAGIC,
            display_active: DisplayActive::Vario,
            glider_idx: 104,
            volume: 0,
        }
    }
}


/// Metastructure for different control variables
pub struct Control {
    pub fly_mode: FlyMode,
    pub vario_mode: VarioMode,
    pub edit_mode: EditMode,
    pub edit_var: Editable,
    pub edit_ticks: u32,
    pub demo_acitve: bool,
}

impl Default for Control {
    fn default() -> Self {
        Self {
            fly_mode: FlyMode::Circling,
            vario_mode: VarioMode::Vario,
            edit_mode: EditMode::Section,
            edit_var: Editable::ClimbRate,
            edit_ticks: 0,
            demo_acitve: true,
        }
    }
}

/// Sensor Values
///
/// This structure contains all variables that are generated by the Larus sensor box.
pub struct Sensor {
    pub average_climb_rate: Speed,
    pub average_wind: Wind,
    pub climb_rate: Speed,
    pub density: Density,
    pub pressure: Pressure,
    pub wind: Wind,
    pub airspeed: AirSpeed,
}

impl Default for Sensor {
    #[allow(unused)]
    fn default() -> Self {
        Sensor {
            average_climb_rate: 1.1.m_s(),
            average_wind: Wind::new(15.0.km_h(), 80.0.deg()),
            climb_rate: 1.7.m_s(),
            density: Density::AT_NN(),
            pressure: Pressure::AT_NN(),
            wind: Wind::new(15.0.km_h(), 66.0.deg()),
            airspeed: AirSpeed::from_tas_at_nn(100.0.km_h()),
        }
    }
}
