use embedded_graphics::geometry::{Angle, AngleUnit};

use crate::system_of_units::{FloatToSpeed, Speed};

/// Flymode display variants
///
/// Flymode::Circling is displayed while circling upwind. In addition to vario signal and wind,
/// the average climb is also displayed.
///
/// In Flymode::StraightFlight the mean climb is hidden and the speed command is displayed
/// graphically and as a number.#[repr(u8)]
pub enum FlyMode {
    Circling,
    StraightFlight,
}

#[repr(u8)]
pub enum VarioMode {
    Vario,
    SpeedToFly,
}

/// Measured Values
///
/// This structure contains all variables that are generated by the Larus sensor box.
pub struct Measured {
    pub average_climb_rate: Speed,
    pub average_wind_angle: Angle,
    pub average_wind_speed: Speed,
    pub climb_rate: Speed,
    pub speed_to_fly: Speed,
    pub wind_angle: Angle,
    pub wind_speed: Speed,
}

impl Default for Measured {
    #[allow(unused)]
    fn default() -> Self {
        Measured {
            average_climb_rate: 1.1.m_s(),
            average_wind_angle: 80.0.deg(),
            average_wind_speed: 15.0.km_h(),
            climb_rate: 1.7.m_s(),
            speed_to_fly: 127.0.km_h(),
            wind_angle: 66.0.deg(),
            wind_speed: 18.0.km_h(),
        }
    }
}

/// Metastructure for different modes
pub struct Modes {
    pub fly_mode: FlyMode,
    pub vario_mode: VarioMode,
}

impl Default for Modes {
    fn default() -> Self {
        Self {
            fly_mode: FlyMode::Circling,
            vario_mode: VarioMode::Vario,
        }
    }
}

/// Metastructure for calculated or set values
pub struct Calculated {
    pub mc_cready: Speed,
    pub speed_to_fly_dif: Speed,
}

impl Default for Calculated {
    #[allow(unused)]
    fn default() -> Self {
        Calculated {
            mc_cready: 0.7.m_s(),
            speed_to_fly_dif: 3.0.km_h(),
        }
    }
}

/// Data model for the entire device
///
/// In the CoreModel all variables of the display are kept in a structure, which is used by
/// different modules. The CoreModel is filled by the CoreController, which holds the different
/// channels to the data sources like Larus, controls, sensors, inputs and time. The View
/// modules display the data contents. The LCD display and the sound system are the most
/// important ones.
#[derive(Default)]
pub struct CoreModel {
    pub measured: Measured,
    pub calculated: Calculated,
    pub modes: Modes,
}
